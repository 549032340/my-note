# 微前端

### 初识微前端

- 微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将Web应用由单一的单体应用转变为由多个小型前端应用聚合在一起的应用。各个前端应用还可以独立运行、独立开发、独立部署。**微前端不再是单纯的前端框架或者工具，而是一套架构体系**。
- 微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。

### 微前端产生的目的

- 技术架构上进一步的扩展性（模块边界清晰、依赖明确）
- 团队组织上的自治权
- 开发流程上能独立开发、独立交付

##### 1.拆分和细化
- 当下的前端领域，SPA是非常流行的项目形态之一，但是随着项目的完善及应用功能的丰富，SPA变得越来越庞大，越来越难以维护，往往最后就变成了改一处而动全身的局面，项目的开发、维护成本也越来越高。微前端的目的就是将庞大的应用进行拆分解耦，使得每个独立的模块可以进行单独开发、维护及部署，提升效率。
##### 2.整合历史系统
- 在不少的业务中，或多或少的会存在一些历史项目，并且还在照常运行。现在需要将其融合到新项目中，但是由于使用的框架过于老旧，合在一起的话只能重写，浪费时间和精力。不过通过微前端将这些系统进行整合的话就可以在不修改逻辑的同时使得新老两套系统并行运行。

### 实现微前端的方案

| 方案                   | 描述                                                         | 优点                                               | 缺点                                                         |
| ---------------------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| **Nginx路由转发**      | 通过Nginx配置反向代理来实现不同路径映射到不同的应用          | 简单、快速、易配置                                 | 在切换应用时会触发浏览器刷新，影响体验                       |
| **iframe嵌套**         | 父应用是一个单独的页面，每个子应用嵌套一个iframe,父子通信可采用postMessage或者contentWindow方式 | 实现简单，子应用之间自带沙箱，天然隔离，互不影响   | iframe的样式显示、兼容性都具有局限性，太过简单而显得low      |
| **Web Components**     | 每个子应用需要采用纯Web Components 技术编写组件，这是一套全新的开发模式 | 每个子应用拥有独立的script和css，也可以单独部署    | 对于历史系统的改造成本过高，子应用通信较为复杂，容易踩坑     |
| **组合式应用路由分发** | 每个子应用独立构建和部署，运行时由父应用来进行路由管理，应用加载、启动、卸载以及通信机制 | 纯前端改造，体验良好，可无感知切换，子应用互相隔离 | 需要设计和开发，由于父子应用处于同一页面运行，需要解决子应用的样式冲突、变量对象污染、通信机制等技术点 |

##### iframe嵌套实现微前端实例：

![iframe](D:\__GitHub__\my-notes\MicroFrontends\image\iframe.png)

##### 通过以上四种方案的对比可以发现，一个微前端的基座框架需要解决以下问题：

- 路由切换的分发问题
- 主微应用的隔离问题
- 通信问题

其中**组合式应用路由分发**方案改造成本中等并且能满足大部分需求，也不影响各前端应用的体验，是当下各个业务普遍采用的一种方案。

### 组合式应用路由分发方案

##### 组合式应用路由分发方案的核心时"主从"思想，包括一个基座（MainApp）应用和若干个微应用（MicroApp）

- 基座应用大多数是一个前端SPA项目，主要负责应用注册、路由映射、消息下发等

- 微应用是独立的前端项目，这些项目可以使用但不限于Vue、React、Angular、JQuery等框架进行开发，每个微应用注册到基座应用中，由基座进行管理，而且每个微应用都是独立部署，脱离基座也是可以单独访问的。

- 组合式应用路由分发方案基本流程图：

  [![hC3FER.md.jpg](https://z3.ax1x.com/2021/08/23/hC3FER.md.jpg)](https://imgtu.com/i/hC3FER)



### 微前端的路由分发

### 微前端的应用隔离

### 微前端的消息通信

### 微前端的核心是什么？

- 一个字：拆
- 为什么拆已经介绍过了，当前技术环境下使用微前端的原因是：巨石应用造成问题、影响远大于使用微前端的弊端，简短的说就是相对于巨石应用来说，使用微前端利大于弊。
- 怎么拆？这个问题很简单，就是将各个子系统独立开发部署，然后通过使用微前端框架合让这些独立的子系统看起来像一个整体
- 

### 微前端架构具备以下几个核心价值：

- 技术栈无关
  主框架不限制接入应用的技术栈，微应用具备完全自主权

- 独立开发、独立部署
  微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新

- 增量升级

  在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略

- 独立运行时
  每个微应用之间状态隔离，运行时状态不共享

### 是否要用微前端

##### 微前端帮助开发者解决了实际的问题，但是对于每个业务来说，是否适合使用微前端，以及是否正确的使用微前端，还是需要遵循以下一些原则：

1. 微前端最佳的使用场景是一些B端的管理系统，既能兼容集成历史系统，也可以将新的系统集成进来，并且不影响原先的交互体验。
2. 整体的微前端不仅仅是只将系统集成进来，而是整个微前端体系的完善，这其中就包括：
   1)：基座应用和微应用的自动部署能力。
   2)：微应用的配置管理能力。
   3)：本地开发调试能力。
   4)：线上监控和统计能力等等。
   只有将整个能力体系搭建完善，才能说是整个微前端体系流程的完善。
3. 当发现使用微前端反而使效率变低，简单的变更复杂那就说明微前端并不适用。

### 微前端有哪些框架

- [Mooa](https://www.npmjs.com/package/mooa)：基于Angular的微前端服务框架
- [Single-Spa](https://www.npmjs.com/package/single-spa)：最早的微前端框架，兼容多种前端技术栈。
- [Qiankun](https://www.npmjs.com/package/qiankun)：基于Single-Spa，阿里系开源微前端框架。
- [Icestark](https://www.npmjs.com/package/icestark)：阿里飞冰微前端框架，兼容多种前端技术栈，基座主要是使用React。
- [Ara Framework](https://www.npmjs.com/package/https://ara-framework.github.io/website/docs/quick-start)：由服务端渲染延伸出的微前端框架。

# [QianKun](https://qiankun.umijs.org/zh/guide)


### 踩坑

##### 1.子应用接入之后接口报404

  - 子应用的代理失效了，所有的接口请求被转移到了父应用上，所以需要给父应用添加代理

##### 2.子应用请求静态资源报404

  - 需要修改webpack的publicPath，直接在子应用的src目录下创建`public-path.js`文件，通过此文件修改

    ```js
    /* eslint-disable camelcase */
    if (window.__POWERED_BY_QIANKUN__) {
      // eslint-disable-next-line no-undef
      __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
    }
    ```

    

##### 3.qiankun通过fetch方式获取子应用内容，fetch不支持ie,如果要在ie环境使用qiankun,需要打补丁。

  - [使用 @babel/preset-env 插件完成自动引入 IE 需要的 polyfill 的能力](https://qiankun.umijs.org/zh/faq#qiankun-%E8%83%BD%E5%85%BC%E5%AE%B9-ie-%E5%90%97)


##### 4.父应用和子应用共享cookie问题

- 通过js-cookie插件进行cookie操作，在对已存在的cookie进行覆盖操作时不生效

##### 5.子应用页面覆盖了父应用的页面

